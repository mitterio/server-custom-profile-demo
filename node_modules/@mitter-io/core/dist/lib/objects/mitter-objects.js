"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FetchMode;
(function (FetchMode) {
    FetchMode[FetchMode["Lazy"] = 0] = "Lazy";
    FetchMode[FetchMode["Eager"] = 1] = "Eager";
})(FetchMode = exports.FetchMode || (exports.FetchMode = {}));
var MitterObject = /** @class */ (function () {
    function MitterObject() {
        this.mode = FetchMode.Lazy;
    }
    MitterObject.prototype.init = function (fetchCall, mode) {
        var _this = this;
        if (mode === void 0) { mode = FetchMode.Lazy; }
        this.fetchCall = fetchCall;
        this.mode = mode;
        if (mode === FetchMode.Eager) {
            fetchCall().then(function (ref) {
                _this._ref = ref;
            });
        }
    };
    MitterObject.prototype.sync = function () {
        var _this = this;
        return this.fetchCall().then(function (it) {
            _this.setRef(it);
            return it;
        });
    };
    MitterObject.prototype.setRef = function (ref) {
        this._ref = ref;
    };
    MitterObject.prototype.proxy = function (key) {
        var _this = this;
        if (this._ref !== undefined) {
            return Promise.resolve(this._ref[key]);
        }
        else {
            return (this.sync()
                // TODO. we probably need some deadlock prevention mechanism, this can ideally
                // keep on going on forever
                .then(function (it) {
                _this._ref = it;
                return _this._ref[key];
            }));
        }
    };
    return MitterObject;
}());
exports.MitterObject = MitterObject;
//# sourceMappingURL=mitter-objects.js.map